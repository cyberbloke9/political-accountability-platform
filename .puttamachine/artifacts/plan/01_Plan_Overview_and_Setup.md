# Project Plan: Political Accountability Platform

**Version:** 1.0
**Date:** November 18, 2025
**Generated By:** Claude Sonnet 4.5 (claude-sonnet-4-5-20250929)

<!-- anchor: project-overview -->
## 1. Project Overview

*   **Goal:** Build a citizen-driven platform to track political promises with multi-dimensional community verification and gamification, enabling transparent accountability for political leaders across India.

*   **High-Level Requirements Summary:**
    *   User authentication system with email verification and optional MFA for high-reputation users
    *   Promise submission, tracking, and categorization system with flexible metadata
    *   Multi-dimensional verification workflow (completion status, quality rating, timeline, budget, impact)
    *   Three-stage verification process: initial submission → community review → expert panel (post-MVP)
    *   Citizen scoring system with titles, privileges, and anti-gaming mechanisms
    *   Evidence management supporting images (5 max) and videos (1 max) with storage constraints
    *   Search, filtering, and discovery features for promises and verifications
    *   Leaderboard and user profile pages showcasing citizen achievements
    *   Fraud detection using rule-based heuristics and image verification
    *   Responsive web application optimized for mobile devices
    *   Geographic focus on India with i18n-ready data models for future expansion

*   **Key Assumptions:**
    *   Initial deployment targets 10,000 users within first 3 months
    *   PostgreSQL can handle anticipated load with proper indexing and materialized views
    *   Cloudflare R2 provides sufficient storage performance for evidence media
    *   Community voting with 60% threshold is sufficient for most verifications
    *   Users accept 10-minute delay in citizen score updates
    *   English-only UI is acceptable for MVP (Hindi in Phase 2)
    *   Rule-based fraud detection catches 80%+ of malicious submissions
    *   Operating budget of ~$100-200/month is sustainable during validation phase
    *   Beta testing with 100 users provides sufficient validation before public launch
    *   MIT license and open-source model attracts community contributors

<!-- anchor: core-architecture -->
## 2. Core Architecture

*   **Architectural Style:** Three-tier monolithic architecture with service layer abstraction, designed for rapid development and straightforward deployment while maintaining clear separation of concerns for future modularization if scaling demands require it.

*   **Technology Stack:**
    *   **Frontend:** Next.js 14 (App Router), React 18, TypeScript, Tailwind CSS, Shadcn/ui components, React Query for data fetching, Zustand for client state
    *   **Backend:** Node.js 20 LTS, Express.js 4.x, TypeScript, Zod for validation, JWT for authentication
    *   **Database:** PostgreSQL 15+ with JSONB support, managed via Supabase or Railway
    *   **Storage:** Cloudflare R2 for evidence media (images/videos)
    *   **CDN:** Cloudflare CDN for static assets and image delivery
    *   **Image Processing:** Sharp library for compression and thumbnail generation
    *   **Email:** SendGrid for transactional emails (verification, notifications)
    *   **Fraud Detection:** Google Cloud Vision API for reverse image search
    *   **Deployment:** Vercel (frontend), Railway (backend), Cloudflare R2 (storage)
    *   **Monitoring:** Sentry for error tracking, Simple Analytics for privacy-friendly analytics
    *   **Other Key Libraries:** Argon2 (password hashing), TOTP libraries (MFA), Rate limiting middleware

*   **Key Components/Services:**
    *   **Authentication Service:** Handles user registration, login, JWT token management, password reset, email verification, and optional MFA for high-reputation users
    *   **Promise Management Service:** CRUD operations for political promises, categorization, status tracking, and association with political entities
    *   **Verification Pipeline Service:** Manages three-stage verification workflow (submission → community review → expert panel), evidence validation, and status transitions
    *   **Citizen Scoring Service:** Calculates and updates citizen scores via materialized views, manages title progression, enforces rate limits and anti-gaming rules
    *   **Evidence Storage Service:** Handles media uploads to R2, automatic image compression/conversion, thumbnail generation, and duplicate detection
    *   **Fraud Detection Service:** Implements rule-based heuristics, integrates Google Vision API, detects coordinated voting and sock puppets
    *   **Community Voting Service:** Manages vote submission, weighted voting based on citizen titles, vote aggregation, and verification resolution
    *   **Search and Discovery Service:** Implements filtering, sorting, and search across promises and verifications
    *   **Notification Service:** Email-based notifications for verification status changes, score milestones, and system alerts
    *   *Component Diagram showing service interactions planned (see I1.T2)*
    *   *Sequence Diagrams for verification workflow and voting process planned (see I2.T1)*

*   **Data Model Overview:**
    *   **Core Entities:** Users (with citizen_score, title, reputation), Promises (with flexible JSONB metadata), Verifications (multi-dimensional ratings), Votes (weighted by user reputation), Evidence (metadata pointing to R2), PoliticalEntities (hierarchical structure for countries/states/constituencies)
    *   **Relationships:** Users create Promises and Verifications, Users vote on Verifications, Verifications link to Promises and Evidence, Promises associate with PoliticalEntities
    *   **Materialized Views:** citizen_scores_mv (refreshed every 10 minutes), promise_statistics_mv (aggregated metrics), verification_queue_mv (pending reviews)
    *   **JSONB Fields:** Promise.metadata (flexible promise details), PoliticalEntity.metadata (country-specific fields), User.preferences (UI settings, notification preferences)
    *   *Entity-Relationship Diagram (ERD) planned (see I1.T3)*

*   **API Contract Style:** RESTful API following OpenAPI 3.0 specification with versioning (/api/v1), consistent error response format, pagination for list endpoints, and filtering/sorting query parameters. *Initial OpenAPI specification planned (see I1.T4)*.

*   **Communication Patterns:**
    *   **Frontend ↔ Backend:** RESTful HTTP/JSON over HTTPS, JWT bearer tokens for authentication, React Query for client-side caching and optimistic updates
    *   **Backend ↔ Database:** Connection pooling via node-postgres (pg), parameterized queries to prevent SQL injection, transactions for multi-step operations
    *   **Backend ↔ R2 Storage:** S3-compatible API via AWS SDK, pre-signed URLs for direct browser uploads (future optimization)
    *   **Backend ↔ External APIs:** Google Vision API (fraud detection), SendGrid API (emails), rate-limited with exponential backoff
    *   *Sequence Diagram for verification submission workflow planned (see I2.T1)*

<!-- anchor: key-architectural-artifacts-planned -->
## 2.1. Key Architectural Artifacts Planned

*   **Component Diagram (Mermaid)** - Visualizes major backend services, frontend modules, external dependencies (R2, Vision API, SendGrid), and their interactions. Shows data flow between authentication, promise management, verification pipeline, and scoring services. *(Created in I1.T2)*

*   **Entity-Relationship Diagram (Mermaid)** - Illustrates database schema with tables (users, promises, verifications, votes, evidence, political_entities), primary/foreign key relationships, and key indexes. Includes materialized views for performance optimization. *(Created in I1.T3)*

*   **API Specification (OpenAPI 3.0 YAML)** - Defines all REST endpoints with request/response schemas, authentication requirements, error codes, and example payloads. Covers authentication, promises, verifications, voting, and user profile endpoints. *(Created in I1.T4)*

*   **Verification Workflow Sequence Diagram (Mermaid)** - Details the three-stage verification process from citizen submission through community voting to final resolution, including evidence validation, fraud detection checks, and score updates. *(Created in I2.T1)*

*   **Authentication Flow Diagram (Mermaid)** - Shows registration, login, JWT token issuance/refresh, password reset, email verification, and optional MFA flow for high-reputation users. *(Created in I2.T5)*

*   **Database Migration Scripts (SQL DDL)** - Complete schema definition with CREATE TABLE statements, indexes, constraints, triggers, and initial data seeding for political entities and default configuration. *(Created in I1.T5)*

*   **Citizen Scoring Algorithm Specification (Markdown)** - Documents point allocation rules, title thresholds, anti-gaming mechanisms, penalty system, and materialized view refresh logic with SQL examples. *(Created in I3.T4)*

*   **Fraud Detection Rules Document (Markdown)** - Catalogs rule-based heuristics (velocity limits, coordinated voting detection, image verification), threshold values, manual review triggers, and integration points with Google Vision API. *(Created in I3.T2)*

*   **Deployment Architecture Diagram (Mermaid)** - Maps infrastructure components (Vercel frontend, Railway backend, Supabase PostgreSQL, Cloudflare R2/CDN), network boundaries, environment variables, and CI/CD pipeline flow. *(Created in I5.T1)*

*   **Storage Architecture Document (Markdown)** - Defines R2 bucket structure, image compression pipeline (WebP conversion, thumbnail sizes), retention policies, cost projections, and upgrade triggers for storage limits. *(Created in I2.T3)*

*   **Data Privacy and Security Specification (Markdown)** - Outlines GDPR compliance measures (data export/deletion), password hashing (Argon2id), encryption at rest, audit logging, rate limiting policies, and security event monitoring. *(Created in I4.T2)*

*   **API Rate Limiting Policy (Markdown)** - Documents endpoint-specific rate limits (per user, per IP), sliding window algorithm, backoff strategies, and responses for exceeded limits. *(Created in I4.T3)*

<!-- anchor: directory-structure -->
## 3. Directory Structure

*   **Root Directory:** `political-accountability-platform/`

*   **Structure Definition:**

```
political-accountability-platform/
├── frontend/                          # Next.js application
│   ├── src/
│   │   ├── app/                       # Next.js App Router pages
│   │   │   ├── (auth)/                # Auth route group
│   │   │   │   ├── login/
│   │   │   │   │   └── page.tsx
│   │   │   │   ├── register/
│   │   │   │   │   └── page.tsx
│   │   │   │   ├── verify-email/
│   │   │   │   │   └── page.tsx
│   │   │   │   └── reset-password/
│   │   │   │       └── page.tsx
│   │   │   ├── (main)/                # Main app route group
│   │   │   │   ├── page.tsx           # Landing page
│   │   │   │   ├── promises/
│   │   │   │   │   ├── page.tsx       # Browse promises
│   │   │   │   │   ├── [id]/
│   │   │   │   │   │   └── page.tsx   # Promise detail
│   │   │   │   │   └── submit/
│   │   │   │   │       └── page.tsx   # Submit new promise
│   │   │   │   ├── verify/
│   │   │   │   │   └── [promiseId]/
│   │   │   │   │       └── page.tsx   # Submit verification
│   │   │   │   ├── leaderboard/
│   │   │   │   │   └── page.tsx
│   │   │   │   └── profile/
│   │   │   │       └── [userId]/
│   │   │   │           └── page.tsx
│   │   │   ├── api/                   # API route handlers (if needed)
│   │   │   ├── layout.tsx
│   │   │   └── globals.css
│   │   ├── components/
│   │   │   ├── ui/                    # Shadcn/ui components
│   │   │   │   ├── button.tsx
│   │   │   │   ├── card.tsx
│   │   │   │   ├── input.tsx
│   │   │   │   ├── badge.tsx
│   │   │   │   ├── dialog.tsx
│   │   │   │   └── ... (other ui primitives)
│   │   │   ├── auth/
│   │   │   │   ├── LoginForm.tsx
│   │   │   │   ├── RegisterForm.tsx
│   │   │   │   └── MFASetup.tsx
│   │   │   ├── promises/
│   │   │   │   ├── PromiseCard.tsx
│   │   │   │   ├── PromiseList.tsx
│   │   │   │   ├── PromiseFilters.tsx
│   │   │   │   ├── PromiseForm.tsx
│   │   │   │   └── PromiseStatusBadge.tsx
│   │   │   ├── verifications/
│   │   │   │   ├── VerificationForm.tsx
│   │   │   │   ├── VerificationCard.tsx
│   │   │   │   ├── QualityMetrics.tsx
│   │   │   │   ├── VotingPanel.tsx
│   │   │   │   └── EvidenceGallery.tsx
│   │   │   ├── citizen/
│   │   │   │   ├── CitizenScoreDisplay.tsx
│   │   │   │   ├── TitleBadge.tsx
│   │   │   │   ├── LeaderboardTable.tsx
│   │   │   │   └── AchievementsList.tsx
│   │   │   ├── evidence/
│   │   │   │   ├── ImageUpload.tsx
│   │   │   │   ├── VideoUpload.tsx
│   │   │   │   └── EvidencePreview.tsx
│   │   │   └── layout/
│   │   │       ├── Header.tsx
│   │   │       ├── Footer.tsx
│   │   │       └── Sidebar.tsx
│   │   ├── hooks/
│   │   │   ├── useAuth.ts
│   │   │   ├── usePromises.ts
│   │   │   ├── useVerifications.ts
│   │   │   ├── useCitizenScore.ts
│   │   │   ├── useVoting.ts
│   │   │   └── useEvidenceUpload.ts
│   │   ├── lib/
│   │   │   ├── api-client.ts          # Axios/fetch wrapper
│   │   │   ├── auth-utils.ts
│   │   │   ├── format-utils.ts
│   │   │   └── validation.ts
│   │   ├── store/
│   │   │   ├── auth-store.ts          # Zustand auth state
│   │   │   └── ui-store.ts            # UI preferences
│   │   └── types/
│   │       ├── api.types.ts
│   │       ├── promise.types.ts
│   │       ├── verification.types.ts
│   │       └── user.types.ts
│   ├── public/
│   │   ├── images/
│   │   └── icons/
│   ├── tests/
│   │   ├── unit/
│   │   ├── integration/
│   │   └── e2e/
│   ├── .env.local.example
│   ├── .env.production
│   ├── next.config.js
│   ├── tailwind.config.ts
│   ├── tsconfig.json
│   ├── package.json
│   └── README.md
│
├── backend/                           # Express.js API server
│   ├── src/
│   │   ├── routes/
│   │   │   ├── index.ts               # Route aggregator
│   │   │   ├── auth.routes.ts
│   │   │   ├── promises.routes.ts
│   │   │   ├── verifications.routes.ts
│   │   │   ├── votes.routes.ts
│   │   │   ├── users.routes.ts
│   │   │   └── evidence.routes.ts
│   │   ├── controllers/
│   │   │   ├── auth.controller.ts
│   │   │   ├── promises.controller.ts
│   │   │   ├── verifications.controller.ts
│   │   │   ├── votes.controller.ts
│   │   │   ├── users.controller.ts
│   │   │   └── evidence.controller.ts
│   │   ├── services/
│   │   │   ├── auth.service.ts
│   │   │   ├── promises.service.ts
│   │   │   ├── verification-pipeline.service.ts
│   │   │   ├── scoring.service.ts
│   │   │   ├── quality-assessment.service.ts
│   │   │   ├── fraud-detection.service.ts
│   │   │   ├── voting.service.ts
│   │   │   ├── evidence-storage.service.ts
│   │   │   ├── email.service.ts
│   │   │   └── notification.service.ts
│   │   ├── middleware/
│   │   │   ├── auth.middleware.ts     # JWT verification
│   │   │   ├── validation.middleware.ts
│   │   │   ├── rate-limit.middleware.ts
│   │   │   ├── error-handler.middleware.ts
│   │   │   └── logging.middleware.ts
│   │   ├── models/
│   │   │   ├── User.model.ts
│   │   │   ├── Promise.model.ts
│   │   │   ├── Verification.model.ts
│   │   │   ├── Vote.model.ts
│   │   │   ├── Evidence.model.ts
│   │   │   └── PoliticalEntity.model.ts
│   │   ├── validators/
│   │   │   ├── auth.validators.ts     # Zod schemas
│   │   │   ├── promise.validators.ts
│   │   │   ├── verification.validators.ts
│   │   │   └── vote.validators.ts
│   │   ├── utils/
│   │   │   ├── jwt.utils.ts
│   │   │   ├── password.utils.ts      # Argon2 hashing
│   │   │   ├── email.utils.ts
│   │   │   ├── image.utils.ts         # Sharp processing
│   │   │   ├── pagination.utils.ts
│   │   │   └── error.utils.ts
│   │   ├── config/
│   │   │   ├── database.config.ts
│   │   │   ├── storage.config.ts
│   │   │   ├── email.config.ts
│   │   │   └── app.config.ts
│   │   ├── types/
│   │   │   ├── express.d.ts           # Extended Express types
│   │   │   ├── api.types.ts
│   │   │   └── domain.types.ts
│   │   ├── jobs/
│   │   │   ├── score-refresh.job.ts   # Materialized view refresh
│   │   │   ├── evidence-cleanup.job.ts
│   │   │   └── notification-batch.job.ts
│   │   ├── index.ts                   # App entry point
│   │   └── server.ts                  # HTTP server setup
│   ├── database/
│   │   ├── migrations/
│   │   │   ├── 001_initial_schema.sql
│   │   │   ├── 002_add_indexes.sql
│   │   │   ├── 003_materialized_views.sql
│   │   │   └── ... (future migrations)
│   │   ├── seeds/
│   │   │   ├── 001_political_entities.sql
│   │   │   └── 002_test_data.sql
│   │   └── schema.sql                 # Complete schema
│   ├── tests/
│   │   ├── unit/
│   │   │   ├── services/
│   │   │   ├── controllers/
│   │   │   └── utils/
│   │   ├── integration/
│   │   │   ├── api/
│   │   │   └── database/
│   │   └── fixtures/
│   │       ├── users.fixture.ts
│   │       └── promises.fixture.ts
│   ├── .env.example
│   ├── .env.test
│   ├── .env.production
│   ├── tsconfig.json
│   ├── package.json
│   ├── jest.config.js
│   └── README.md
│
├── docs/                              # Documentation and design artifacts
│   ├── diagrams/
│   │   ├── component-diagram.mmd      # Mermaid source
│   │   ├── erd.mmd                    # Entity-Relationship Diagram
│   │   ├── verification-workflow.mmd  # Sequence diagram
│   │   ├── auth-flow.mmd              # Authentication flow
│   │   └── deployment-architecture.mmd
│   ├── specifications/
│   │   ├── citizen-scoring-algorithm.md
│   │   ├── fraud-detection-rules.md
│   │   ├── storage-architecture.md
│   │   ├── data-privacy-security.md
│   │   └── rate-limiting-policy.md
│   ├── adr/                           # Architectural Decision Records
│   │   ├── 001-use-postgresql-only.md
│   │   ├── 002-defer-expert-panel.md
│   │   ├── 003-cloudflare-r2-storage.md
│   │   └── 004-batch-score-updates.md
│   └── guides/
│       ├── development-setup.md
│       ├── deployment-guide.md
│       └── contributing.md
│
├── api/                               # API specifications
│   ├── openapi.yaml                   # OpenAPI 3.0 spec
│   └── postman-collection.json
│
├── config/                            # Shared configuration
│   ├── docker-compose.yml             # Local dev environment
│   ├── .env.example
│   └── nginx.conf                     # If using nginx
│
├── scripts/                           # Utility scripts
│   ├── setup-dev.sh                   # Dev environment setup
│   ├── run-migrations.sh
│   ├── seed-database.sh
│   └── deploy.sh
│
├── .github/
│   ├── workflows/
│   │   ├── frontend-ci.yml
│   │   ├── backend-ci.yml
│   │   └── deploy-production.yml
│   ├── ISSUE_TEMPLATE/
│   └── PULL_REQUEST_TEMPLATE.md
│
├── .gitignore
├── LICENSE                            # MIT License
├── README.md                          # Project overview
├── QUICK_START.md                     # Existing quick start guide
├── RUN_MANUALLY.md                    # Existing manual run guide
└── CONTRIBUTING.md                    # Contribution guidelines
```

**Key Design Choices:**

*   **Monorepo Structure:** Frontend and backend in separate top-level directories for clear separation, easier independent deployment, and potential future extraction into separate repositories if needed.

*   **Next.js App Router:** Leverages route groups `(auth)` and `(main)` for logical organization without affecting URL structure, enabling shared layouts and middleware.

*   **Docs Organization:** Centralizes all architectural artifacts in `docs/` with subdirectories for diagrams (Mermaid source files), specifications (Markdown), ADRs (decision tracking), and guides (setup/deployment).

*   **API Specifications:** Dedicated `api/` directory for OpenAPI spec and Postman collection, enabling API-first development and easy client generation.

*   **Database Migrations:** Versioned SQL migration files in `backend/database/migrations/` for repeatable, auditable schema changes across environments.

*   **Test Co-location:** Tests organized by type (unit/integration/e2e) within frontend and backend directories for better discoverability and maintainability.

*   **Shared Config:** Top-level `config/` for Docker Compose and environment templates used across both frontend and backend.

*   **GitHub Workflows:** CI/CD pipelines separated by component (frontend-ci, backend-ci) for faster, parallel builds and independent deployments.

<!-- anchor: directives-strict-process -->
## 4. DIRECTIVES & STRICT PROCESS

#### **Command Usage Constraints**

Do NOT use exploratory or planning commands or listing commands (`ls`, `la`, `ll`, `dir`) except:
1. When explicitly instructed by the protocol
2. Before escalating critical errors for diagnostic information

**Rationale:** Minimize unnecessary output and token consumption. Focus on execution, not exploration.

---

**1. Internal Content Blueprint:** Before generating any output, the first step **MUST** be to create a silent, internal plan. Mentally calculate the target line counts for each section based on the project scale and content distribution percentages. This blueprint is for internal reasoning only and **MUST NOT** be included in the final output. The entire generation process will follow this internal plan.

**2. In-Memory Content Buffering:** Generate the complete and final content for the entire file in a single, continuous thought process. As content is generated for each section according to the blueprint, hold it all in an internal memory buffer. Do not start any file-writing command until the content for the *entire file* is finalized in this buffer.

**3. Single Atomic Write Operation:** Once the buffer contains the complete file content, write it to the specified path in a **single, atomic command**. This command must create or overwrite the file.

**4. Final Verification and Targeted Correction:** Immediately after the single write operation, perform one final, rapid verification.
    *   **A. Fast Check:** Verify the file's line count and file existence using a **single, one-line Python command**
    *   **B. Targeted Append:** If and only if the line count is below the required minimum, append the necessary lines by adding relevant, contextual detail

---

**Execution Guidelines for Autonomous Agents:**

*   **Task Isolation:** Each task should be completable independently once its dependencies are satisfied. Agents should not need to coordinate state beyond reading specified input files and writing to target files.

*   **Idempotency:** Tasks involving file creation/modification should be idempotent where possible. Running a task multiple times with the same inputs should produce the same result.

*   **Error Handling:** Agents must validate inputs before processing and provide clear, actionable error messages if prerequisites are not met or inputs are invalid.

*   **Artifact Validation:** For tasks generating diagrams or specifications:
    *   Validate syntax before finalizing (e.g., Mermaid CLI for diagrams, OpenAPI validators for specs)
    *   Include comments/documentation within artifacts explaining key decisions
    *   Ensure artifacts are human-readable and version-control friendly (text-based formats)

*   **Testing Requirements:** Code tasks must include corresponding tests unless explicitly marked as test tasks themselves. Acceptance criteria will specify minimum coverage or specific test scenarios.

*   **Documentation:** Any non-obvious implementation decisions must be documented inline (code comments) or in commit messages. Complex algorithms should reference relevant specification documents.

*   **Dependency Resolution:** Before starting a task, verify all prerequisite tasks are completed and their deliverables exist at specified paths. If not, report blocked status with specific missing dependencies.
